package elfutils

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"

	gtutils "github.com/pangine/disasm-gt-generator/gtutils"
	objx86elf "github.com/pangine/pangineDSM-obj-x86-elf"
	genutils "github.com/pangine/pangineDSM-utils/general"
	pstruct "github.com/pangine/pangineDSM-utils/program-struct"
)

// LstChangeFlag is the comment to put into LST as a flag represent changed
const LstChangeFlag string = "#Pangine_GT_inst:"

// GasLineBufferSize is to set the buffer size of gas read line using "--listing-rhs-width=NUM"
const GasLineBufferSize int = 1024

// CleanupLst is used to remove files generated by this util
func CleanupLst(path string) {
	exts := []string{".fm.s", ".mbu.s", ".sbu.s", ".tmp.s", ".lst"}
	for _, ext := range exts {
		files := genutils.GetFiles(path, ext)
		for _, file := range files {
			os.Remove(filepath.Join(path, file))
		}
	}
}

/*AsmFormalize is to formalize assembly files genereated by different compilers.
 *It does following things:
 *	connect strings after ".file" (clang)
 *	remove duplicated labels (icc)
 *	return instructions connected with ";"
 *	make "prefix inst" into two seperate instructions
 *Return the name of the formalized file
 */
func AsmFormalize(path, file string) string {
	if !strings.HasSuffix(file, ".s") {
		fmt.Printf("FATAL: Formalizer should only work on .s files but get %s\n", file)
		panic(nil)
	}
	fmFile := file[:len(file)-2] + ".fm.s"
	oldFile := filepath.Join(path, file)
	newFile := filepath.Join(path, fmFile)

	// Open files for read and write
	bin, err := os.Open(oldFile)
	if err != nil {
		fmt.Printf("FATAL: asm file %s can not be read.\n", oldFile)
		panic(err)
	}
	defer bin.Close()
	bout, err := os.Create(newFile)
	if err != nil {
		fmt.Printf("FATAL: asm file %s can not be write.\n", newFile)
		panic(err)
	}
	defer bout.Close()
	reader := bufio.NewScanner(bin)
	writer := bufio.NewWriter(bout)
	defer writer.Flush()

	var i int
	labels := make(map[string]bool)
	var lastLineNotEnd bool
	for reader.Scan() {
		i++
		if i%1000 == 0 {
			writer.Flush()
		}

		line := reader.Text()
		fields := strings.Fields(line)
		// Empty line
		if len(fields) == 0 {
			if !lastLineNotEnd {
				writer.WriteString(line + "\n")
			}
			continue
		}
		// Check if line is .file ...
		if len(fields) >= 2 && fields[0] == ".file" && !lastLineNotEnd {
			line = strings.ReplaceAll(line, "\" \"", "/")
			writer.WriteString(line + "\n")
			continue
		}
		// Check if line is a label
		if strings.HasPrefix(fields[0], ".") &&
			strings.HasSuffix(fields[0], ":") {
			if _, ok := labels[fields[0]]; !ok {
				// Not duplicated
				if lastLineNotEnd {
					fmt.Println("WARNING: label after a prefix instruction: " + file + ":" + line)
				} else {
					labels[fields[0]] = true
					writer.WriteString(line + "\n")
				}
			}
			continue
		}
		// Check if line is instruction
		if !strings.HasPrefix(fields[0], ".") &&
			!strings.HasSuffix(fields[0], ":") {
			lastLineNotEnd = checkInsn(line, fields, writer, lastLineNotEnd)
		} else {
			if lastLineNotEnd {
				if strings.HasPrefix(fields[0], ".") {
					lastLineNotEnd = false
					writer.WriteString("\n")
					fmt.Println("WARNING: data/directive after a prefix instruction: " + file + ":" + line)
					// Will actually generate an error in gt generation
				}
				// Just comment, ignore it
			} else {
				writer.WriteString(line + "\n")
			}
			continue
		}
	}
	return fmFile
}

// checkInsn is the recursive instruction formalization function for AsmFormalize
func checkInsn(line string, fields []string, writer *bufio.Writer, lastLineNotEnd bool) bool {
	var lastIsPrefix bool
	for i, field := range fields {
		// Comments
		if strings.HasPrefix(field, "#") ||
			strings.HasPrefix(field, "//") {
			if i == 0 && lastLineNotEnd {
				// Last line not yet end, skip the comment to prevent later useful information from being commented out
				return lastLineNotEnd
			}
			if !lastIsPrefix {
				writer.WriteString(line + "\n")
				return false
			}
			// Last instruction piece is a prefix instruction, cat the next line together
			index := strings.Index(line, field)
			writer.WriteString(line[:index] + " ")
			return true
		}
		// Search for ";"
		if strings.Index(field, ";") >= 0 {
			indexInField := strings.Index(field, ";")
			firstHalf := field[:indexInField]
			index := strings.Index(line, ";")
			var lineNotEnd bool
			if _, ok := objx86elf.PrefixMap[firstHalf]; ok || (len(firstHalf) == 0 && lastIsPrefix) {
				lineNotEnd = true
				writer.WriteString(line[:index] + " ")
			} else {
				writer.WriteString(line[:index] + "\n")
			}
			line = line[index+1:]
			return checkInsn(line, strings.Fields(line), writer, lineNotEnd)
		}
		// Search for prefix instructions
		_, lastIsPrefix = objx86elf.PrefixMap[field]
	}
	if !lastIsPrefix {
		writer.WriteString(line + "\n")
		return false
	}
	writer.WriteString(line + " ")
	return true
}

// GenerateLst calls GNU as to translate assembly file to lsting file
func GenerateLst(path, sFile, dFile string, gnuPrefix bool, llvmTripleStruct genutils.LlvmTripleStruct) {
	as := "as"
	if gnuPrefix {
		as = "gas"
	}
	sFile = filepath.Join(path, sFile)
	dFile = filepath.Join(path, dFile)
	args := []string{sFile,
		"--listing-rhs-width=" + strconv.Itoa(GasLineBufferSize),
		"-almns=" + dFile,
		"-o", "/dev/null"}
	if llvmTripleStruct.Arch == "x86" {
		args = append(args, "--32")
	}
	asCmd := exec.Command(as, args...)
	asCmd.Start()
	asCmd.Wait()
}

// ReadLst read the LST input and output the instructions and labels information
func ReadLst(
	path, file string,
) (
	funcMap map[string]*gtutils.LstFunc,
) {
	file = filepath.Join(path, file)
	bin, finerr := os.Open(file)
	if finerr != nil {
		fmt.Printf("\tFATAL: %s cannot be open\n", file)
		panic(finerr)
	}
	defer bin.Close()
	funcMap = make(map[string]*gtutils.LstFunc)

	// First iteration
	funcList := make(map[string]bool)
	// Search for functions to output
	lines := bufio.NewScanner(bin)
	for lines.Scan() {
		fields := strings.Fields(lines.Text())
		if len(fields) < 3 {
			continue
		}
		if strings.HasPrefix(fields[0], "#") ||
			strings.HasPrefix(fields[1], "#") ||
			strings.HasPrefix(fields[2], "#") {
			continue
		}
		if len(fields) >= 3 && strings.HasSuffix(fields[2], ",@function") {
			fields = []string{fields[0], fields[1], strings.TrimSuffix(fields[2], "@function"), "@function"}
		}
		if len(fields) >= 4 && fields[3] == "@function" {
			fName := strings.TrimSuffix(fields[2], ",")
			funcList[fName] = true
		}
	}
	// Reset scanner
	bin.Seek(0, io.SeekStart)

	// Second iteration, record instructions and labels in functions
	var inTextSection, inFunction, startFunction, sameLineAsLast, lastIsAlign bool
	var fName, lName string
	var funcOffset, lastLine, lastInsnLine, labelIndex int
	sourceList := make(map[int]string)
	lines = bufio.NewScanner(bin)
	for lines.Scan() {
		line := lines.Text()
		fields := strings.Fields(line)
		if len(fields) < 2 {
			continue
		}

		// In .text section
		// .text
		// .section .text
		// .section .text.SOME_LABELS  (startup, unlikely, ...)
		// (may be more)
		if fields[1] == ".text" ||
			(len(fields) > 2 &&
				fields[1] == ".section" &&
				(fields[2] == ".text" ||
					strings.HasPrefix(fields[2], ".text."))) {
			inTextSection = true
		} else if fields[1] == ".section" {
			// In Other sections
			inTextSection = false
		}

		// Get line number
		sameLineAsLast = false
		lineNumber64, err := strconv.ParseInt(fields[0], 10, 64)
		lineNumber := int(lineNumber64)
		if err == nil {
			if lastLine == lineNumber {
				sameLineAsLast = true
			} else {
				lastLine = lineNumber
			}
		}

		// Get present offset
		// Line numbers in LSTs are reprented in 2 bytes only
		offset64, offsetErr := strconv.ParseInt(fields[1], 16, 64)
		offset := int(offset64)
		/*if inTextSection {
			if err == nil && !sameLineAsLast {
				if offset < lastOffset {
					hiddenHigh++
				}
				lastOffset = offset
			}
			offset += hiddenHigh << 16 //16^4
		}*/

		if fields[1] == ".file" && len(fields) >= 4 {
			// .file sources
			if num, err := strconv.ParseInt(fields[2], 10, 64); err == nil {
				source := fields[len(fields)-1]
				cutFrom := strings.LastIndex(source, "/")
				if cutFrom == -1 {
					cutFrom = strings.Index(source, "\"")
				}
				cutFrom++
				cutTo := strings.LastIndex(source, "\"")
				if cutTo > cutFrom {
					sourceList[int(num)] = source[cutFrom:cutTo]
				}
			}
			continue
		}
		if strings.HasSuffix(fields[1], ":") &&
			funcList[fields[1][:len(fields[1])-1]] {
			// Pattern "func_name:"
			fName = fields[1][:len(fields[1])-1]
			funcMap[fName] = &gtutils.LstFunc{}
			startFunction = true
			inFunction = true
			lName = fields[1]
			labelIndex = 0
			lastIsAlign = false
			continue
		}
		if fields[1] == ".cfi_endproc" {
			inFunction = false
			continue
		}
		if !inFunction {
			continue
		}

		if strings.HasPrefix(fields[1], ".") &&
			strings.HasSuffix(fields[1], ":") {
			//Pattern ".label:"
			lName = fields[1]
			labelIndex = 0
			lastIsAlign = false
			continue
		}
		if len(fields) > 3 && fields[1] == ".loc" {
			// Specify source code file for this function
			ref, err := strconv.ParseInt(fields[2], 10, 64)
			_, ok := sourceList[int(ref)]
			if funcMap[fName].Source == "" && ok && err == nil {
				funcMap[fName].Source = sourceList[int(ref)]
			}
			continue
		}
		if inTextSection &&
			offsetErr == nil &&
			len(fields) >= 4 &&
			(fields[3][0] != '.' ||
				strings.Index(line, LstChangeFlag) >= 0 ||
				strIsAlign(fields[3])) {
			// line# offset hex opcode ...
			// line# offset hex .byte ... #Pangine_GT_inst ...
			// line# offset hex .p2align, .align, ...
			_, err := strconv.ParseInt(fields[2], 16, 64)
			if err == nil {
				if startFunction {
					startFunction = false
					funcOffset = offset
				}
				relativeOffset := offset - funcOffset
				funcMap[fName].FuncLen = relativeOffset + len(fields[2])/2
				if labelIndex == 0 {
					funcMap[fName].LabelAry = append(
						funcMap[fName].LabelAry,
						gtutils.LstLabel{
							Offset: relativeOffset,
							Name:   lName,
						},
					)
				}
				var isAlign bool
				if strIsAlign(fields[3]) {
					if lastIsAlign {
						// Two neighboring align, considered as one
						funcMap[fName].InsnAry[len(funcMap[fName].InsnAry)-1].Length += len(fields[2]) / 2
						continue
					}
					isAlign = true
					lastIsAlign = true
				} else {
					lastIsAlign = false
				}
				funcMap[fName].InsnAry = append(
					funcMap[fName].InsnAry,
					gtutils.LstInsn{
						Offset:  relativeOffset,
						Length:  len(fields[2]) / 2,
						IsAlign: isAlign,
						Label:   lName,
						Index:   labelIndex,
					},
				)
				labelIndex++
				lastInsnLine = lineNumber
			}
			continue
		}
		if sameLineAsLast && lastInsnLine == lineNumber {
			// length of last Insn needs extends
			funcMap[fName].InsnAry[len(funcMap[fName].InsnAry)-1].Length += len(fields[1]) / 2
			funcMap[fName].FuncLen += len(fields[1]) / 2
			continue
		}
		if inTextSection &&
			offsetErr == nil &&
			len(fields) >= 4 &&
			fields[3][0] != '.' {
			// line# offset hex .byte ...
			relativeOffset := offset - funcOffset
			funcMap[fName].FuncLen = relativeOffset + len(fields[2])/2
			continue
		}
		if offsetErr == nil {
			lastIsAlign = false
			continue
		}
	}
	// remove tail align
	for f, v := range funcMap {
		var removeInsn, removeLabel int
		for i := len(v.InsnAry) - 1; i >= 0; i-- {
			if v.InsnAry[i].IsAlign == false {
				break
			}
			removeInsn++
			if v.InsnAry[i].Index == 0 {
				removeLabel++
			}
		}
		funcMap[f].InsnAry = funcMap[f].InsnAry[:len(v.InsnAry)-removeInsn]
		funcMap[f].LabelAry = funcMap[f].LabelAry[:len(funcMap[f].LabelAry)-removeLabel]
	}
	return
}

func strIsAlign(str string) bool {
	return strings.HasPrefix(str, ".") && strings.HasSuffix(str, "align")
}

var meBinaryOps = map[string]bool{
	"add": true,
	"or":  true,
	"adc": true,
	"sbb": true,
	"and": true,
	"sub": true,
	"xor": true,
	"cmp": true,
}

var meShiftOps = map[string]bool{
	"shl": true,
	"shr": true,
	"sar": true,
}

/*CheckMultipleEncoding returen true if the insn size differences is because of
 *multiple encoding of the same assembly instruction.
 * TBD: detect using machine code?
 *Presently support:
 *	JMP:			[discovered in all compilers]
 *		jmp	ADDR			(near:2, far: 5)
 *		jcc	ADDR			(near:2, far: 6)
 *	Binary Ops imm8:	[discovered first in clang 3.8.0 i386]
 *		opc: add, or, adc, sbb, and, sub, xor, cmp
 *		$NUM >= MAX_INT - 0x7f || $NUM >= -128 && $NUM <= 127
 *		(opc)w	$NUM, %REG	(imm8: 4, imm16: 4) // does not matter
 *		(opc)l	$NUM, %REG	(imm8: 3, imm32: 6)
 *		(opc)q	$NUM, %REG	(imm8: 4, imm32: 7)
 *		Can comnbine Binary Ops if %REG is ax
 *	Binary Ops ax:		[discovered first in clang 6.0 i386]
 *		opc: add, or, adc, sbb, and, sub, xor, cmp
 *		(opc)b	$NUM, %al	(al:  2, <reg:al>:  3)
 *		(opc)w	$NUM, %ax	(ax:  4, <reg:ax>:  5)
 *		(opc)l	$NUM, %eax	(eax: 5, <reg:eax>: 6)
 *		(opc)q	$NUM, %rax	(rax: 6, <reg:rax>: 7)
 *	MOV ax (i386 only): 	[discovered first in icc 19.0.1]
 *		movb	ADDR, %al	(al:  5, <reg:al>:  6)
 *		movb	%al, ADDR	(al:  5, <reg:al>:  6)
 *		movw	ADDR, %ax	(ax:  6, <reg:ax>:  7)
 *		movw	%ax, ADDR	(ax:  6, <reg:ax>:  7)
 *		movl	ADDR, %eax	(eax: 5, <reg:eax>: 6)
 *		movl	%eax, ADDR	(eax: 5, <reg:eax>: 6)
 *	IMUL imm8:		[discovered first in clang 3.8.0 i386]
 *		$NUM >= MAX_INT - 0x7f || $NUM >= -128 && $NUM <= 127
 *		imulw	$NUM, m(%REG1), %REG2	(imm8: 5, imm16: 6)
 *		imull	$NUM, m(%REG1), %REG2	(imm8: 4, imm16: 7)
 *		imul1	$NUM, m(%REG1), %REG2	(imm8: 5, imm16: 8)
 *	Shift 1 bit:		[discovered first in clang 3.8.0 i386]
 *		opc: shl, shr, sar (sal is the same as shl in machine code)
 *		(opc)b  $1, %REG	(opc %REG: 2, opc $1, %REG: 3)
 *		(opc)w  $1, %REG	(opc %REG: 3, opc $1, %REG: 4)
 *		(opc)l  $1, %REG	(opc %REG: 2, opc $1, %REG: 3)
 *		(opc)q  $1, %REG	(opc %REG: 3, opc $1, %REG: 4)
 */
func CheckMultipleEncoding(insn pstruct.InstFlags, lstInsnSize int) bool {
	//Count Prefixes length
	var pfxLen int
	for _, prefix := range insn.Prefixes {
		pfxLen += objx86elf.PrefixMap[prefix]
	}
	cmpLstInsnSize := lstInsnSize - pfxLen
	cmpObjInsnSize := insn.InstSize - pfxLen
	//Check if is jmp
	if insn.IsJmp && !insn.IsIndJmp &&
		intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 2, 5) {
		return true
	}
	//Check if is jcc
	if insn.IsConditional && !insn.IsIndJmp &&
		intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 2, 6) {
		return true
	}
	fields := strings.Fields(insn.OriginInst)
	//Check if is binary ops
	if len(fields) >= 3 && len(fields[0]) >= 3 && len(fields[1]) >= 3 &&
		strings.HasPrefix(fields[2], "%") &&
		strings.HasPrefix(fields[1], "$") && strings.HasSuffix(fields[1], ",") {
		opc := fields[0][:len(fields[0])-1]
		_, ok0 := meBinaryOps[opc]
		strNum := fields[1][1 : len(fields[1])-1]
		num64, err1 := strconv.ParseInt(strNum, 10, 64)
		num := int(num64)
		if ok0 && err1 == nil {
			var isBiOpLarge bool
			//Check if is imm8 case
			//Only need to consider int32 cases,
			//because for andw the two encodings are of the same length
			if num >= 0xffffff80 || (num >= -128 && num <= 127) {
				//Check if is 32, or 64 bits
				if strings.HasSuffix(fields[0], "l") {
					if intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 3, 6) {
						return true
					}
					// Can combine the condition with Binary ops ax
					isBiOpLarge = true
				}
				if strings.HasSuffix(fields[0], "q") {
					if intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 4, 7) {
						return true
					}
					isBiOpLarge = true
				}
			}
			//CHeck if is register ax cases
			//Check if is 8, 16, 32, or 64 bits
			if strings.HasSuffix(fields[0], "b") &&
				fields[2] == "%al" &&
				intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 2, 3) {
				return true
			}
			if strings.HasSuffix(fields[0], "w") &&
				fields[2] == "%ax" &&
				intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 4, 5) {
				return true
			}
			if strings.HasSuffix(fields[0], "l") &&
				fields[2] == "%eax" &&
				(intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 5, 6) ||
					(isBiOpLarge && intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 3, 5))) {
				return true
			}
			if strings.HasSuffix(fields[0], "q") &&
				fields[2] == "%rax" &&
				(intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 6, 7) ||
					(isBiOpLarge && intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 4, 6))) {
				return true
			}
		}
	}
	//Check if is mov ax (i386)
	if len(fields) >= 3 && len(fields[0]) == 4 &&
		strings.HasPrefix(fields[0], "mov") {
		regAt1 := strings.HasPrefix(fields[1], "%")
		regAt2 := strings.HasPrefix(fields[2], "%")
		// Only one can be register
		if regAt1 != regAt2 {
			var reg string
			var intParseErr error
			//Remove comma
			if regAt1 {
				reg = fields[1][:len(fields[1])-1]
				_, intParseErr = strconv.ParseInt(fields[2], 10, 64)
			} else {
				reg = fields[2]
				_, intParseErr = strconv.ParseInt(fields[1][:len(fields[1])-1], 10, 64)
			}
			if intParseErr == nil {
				//Check if is 8, 16 or 32 bits
				if strings.HasSuffix(fields[0], "b") &&
					reg == "%al" &&
					intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 5, 6) {
					return true
				}
				if strings.HasSuffix(fields[0], "w") &&
					reg == "%ax" &&
					intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 6, 7) {
					return true
				}
				if strings.HasSuffix(fields[0], "l") &&
					reg == "%eax" &&
					intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 5, 6) {
					return true
				}
			}
		}
	}
	//Check if is IMUL
	if len(fields) >= 4 && len(fields[0]) == 5 &&
		strings.HasPrefix(fields[0], "imul") &&
		strings.Index(fields[2], "%") >= 0 &&
		strings.HasPrefix(fields[3], "%") {
		strNum := fields[1][1 : len(fields[1])-1]
		num64, err1 := strconv.ParseInt(strNum, 10, 64)
		num := int(num64)
		fmt.Println("IN!!!!!!!!!!!!")
		fmt.Println(num, strNum)
		if err1 == nil {
			if strings.HasSuffix(fields[0], "w") {
				if num >= 0xff80 || (num >= -128 && num <= 127) {
					if intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 5, 6) {
						return true
					}
				}
			} else if num >= 0xffffff80 || (num >= -128 && num <= 127) {
				if strings.HasSuffix(fields[0], "l") &&
					intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 4, 7) {
					return true
				}
				if strings.HasSuffix(fields[0], "q") &&
					intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 5, 8) {
					return true
				}
			}
		}
	}
	//Check if is shift 1 bit
	if len(fields) >= 2 && len(fields[0]) == 4 && meShiftOps[fields[0][:3]] {
		// shf  %REG or shf  $1, %REG
		if len(fields) == 2 && strings.HasPrefix(fields[1], "%") ||
			len(fields) >= 3 && fields[1] == "$1," && strings.HasPrefix(fields[2], "%") {
			//Check if is 8, 16, 32, or 64 bits
			if strings.HasSuffix(fields[0], "b") &&
				intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 2, 3) {
				return true
			}
			if strings.HasSuffix(fields[0], "w") &&
				intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 3, 4) {
				return true
			}
			if strings.HasSuffix(fields[0], "l") &&
				intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 2, 3) {
				return true
			}
			if strings.HasSuffix(fields[0], "q") &&
				intAreTheTwoNum(cmpLstInsnSize, cmpObjInsnSize, 3, 4) {
				return true
			}
		}
	}
	return false
}

/* intAreTheTwoNum checks if input int pair (i1, i2) belongs to
 * {(n1, n2), (n2, n1), (n1, n1), (n2, n2)}
 */
func intAreTheTwoNum(i1, i2, n1, n2 int) bool {
	return (i1 == n1 || i1 == n2) && (i2 == n1 || i2 == n2)
}

// CopyAsm for modification
func CopyAsm(path, file1, file2 string) {
	fromFile := filepath.Join(path, file1)
	toFile := filepath.Join(path, file2)
	bin, err := os.Open(fromFile)
	if err != nil {
		fmt.Printf("FATAL: cannot open %s\n", fromFile)
		panic(err)
	}
	defer bin.Close()
	bout, err := os.Create(toFile)
	if err != nil {
		fmt.Printf("FATAL: cannot create %s\n", toFile)
		panic(err)
	}
	defer bout.Close()
	_, err = io.Copy(bout, bin)
	if err != nil {
		fmt.Printf("FATAL: file copy failed for %s to %s\n", fromFile, toFile)
	}
	return
}

// DirectivesMapInsert insert the input gtutils.MatchDirective into a gtutils.MatchDirective
// map indexed by label
func DirectivesMapInsert(mdMap map[string]gtutils.MatchDirective, d gtutils.MatchDirective) {
	if _, ok := mdMap[d.Label]; ok {
		panic("Labels duplicated in modify map: " +
			d.Label)
	}
	mdMap[d.Label] = d
}

// ModifyAsm according to directive
func ModifyAsm(path, file string, mdMap map[string]gtutils.MatchDirective) {
	for _, directive := range mdMap {
		fmt.Printf("\t\tModifying %s: %s#%d\n", file, directive.Label, directive.Index)
	}
	if !strings.HasSuffix(file, ".fm.s") {
		fmt.Printf("FATAL: Modifier should only work on .fm.s files but get %s\n", file)
		panic(nil)
	}
	tmpFile := filepath.Join(path, file[:len(file)-5]+".tmp.s")
	sFile := filepath.Join(path, file)
	os.Remove(tmpFile)
	err := os.Rename(sFile, tmpFile)
	if err != nil {
		fmt.Printf("FATAL: renaming error for %s\n", sFile)
		panic(err)
	}
	bin, err := os.Open(tmpFile)
	if err != nil {
		fmt.Printf("FATAL: asm file %s can not be read.\n", tmpFile)
		panic(err)
	}
	defer bin.Close()
	bout, err := os.Create(sFile)
	if err != nil {
		fmt.Printf("FATAL: asm file %s can not be write.\n", sFile)
		panic(err)
	}
	defer bout.Close()
	reader := bufio.NewScanner(bin)
	writer := bufio.NewWriter(bout)
	defer writer.Flush()
	var i int
	var inLabel, lastIsAlign bool
	var insnCounter int
	var directive gtutils.MatchDirective
	for reader.Scan() {
		i++
		if i%1000 == 0 {
			writer.Flush()
		}
		line := reader.Text()
		fields := strings.Fields(line)
		if len(fields) == 0 {
			writer.WriteString(line + "\n")
			continue
		}
		if d, ok := mdMap[fields[0]]; ok {
			directive = d
			inLabel = true
			lastIsAlign = false
			insnCounter = 0
			writer.WriteString(line + "\n")
		} else {
			if !inLabel {
				writer.WriteString(line + "\n")
				continue
			}
			if strings.Index(line, LstChangeFlag) >= 0 ||
				strIsAlign(fields[0]) ||
				(!strings.HasPrefix(fields[0], "#") &&
					!strings.HasPrefix(fields[0], "//") &&
					!strings.HasPrefix(fields[0], ".") &&
					!strings.HasSuffix(fields[0], ":")) {
				// considered as an instruction
				IsAlign := strIsAlign(fields[0])
				if IsAlign && lastIsAlign {
					writer.WriteString(line + "\n")
					continue
				}
				lastIsAlign = IsAlign
				if insnCounter == directive.Index {
					// The instruction to change
					for i, b := range directive.ChangeTo {
						if i != len(directive.ChangeTo)-1 {
							writer.WriteString("\t.byte " + strconv.Itoa(int(b)) + ";")
						} else {
							writer.WriteString("\t.byte " + strconv.Itoa(int(b)))
						}
					}
					writer.WriteString("\t" + LstChangeFlag + "\t" + line + "\n")
					inLabel = false
				} else {
					writer.WriteString(line + "\n")
				}
				insnCounter++
			} else {
				writer.WriteString(line + "\n")
			}
		}
	}
}
